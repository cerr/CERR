function [inflMap, colXCoord, rowYCoord, colDividerXCoord, rowDividerYCoord, rowLeafPositions] = getLSInfluenceMapFactorTG(precisionFluenceMap, LS,leak,beamIndex, MLC, TongueGroove);
%"getLSInfluenceMap"
%   Gets an image of the influence generated by the beam described in LS.
%   Use getDICOMLeafPositions to generate LS.
%
%JRA&KZ 02/8/05
%
%Usage:
%   function inflMap = getLSInfluenceMap(LS);
%
% Copyright 2010, Joseph O. Deasy, on behalf of the CERR development team.
%
% This file is part of The Computational Environment for Radiotherapy Research (CERR).
%
% CERR development has been led by:  Aditya Apte, Divya Khullar, James Alaly, and Joseph O. Deasy.
%
% CERR has been financially supported by the US National Institutes of Health under multiple grants.
%
% CERR is distributed under the terms of the Lesser GNU Public License.
%
%     This version of CERR is free software: you can redistribute it and/or modify
%     it under the terms of the GNU General Public License as published by
%     the Free Software Foundation, either version 3 of the License, or
%     (at your option) any later version.
%
% CERR is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
% without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
% See the GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with CERR.  If not, see <http://www.gnu.org/licenses/>.

%Maximum precision of leaf position, in mm.
%precision = .1;
% JC, AUG 09, 2006, No Need to use 0.1mm precision. Could go larger.

% JC, Sept 19, 2007
% Add MLC modeling,
% 1.
% Shift the MLC positions by using the "MLCTABLE.TXT" files provided by
% Varian.
% 2.
% Round leaf tip.
% 3.
% Inter-leaf-leakage.

if (MLC == 1)
    
    % Only implemented for Varian 120 MLC for now.
    disp('shift the MLC leaf tip by the amount specificed by Varian, using MLCTABLE.mat file');
    try
        load('MLCTABLE.mat', 'MLCTABLE');
    catch
        disp('No MLCTABLE.mat provided');
        pwd
    end
    
    
    for i = 1: length(LS.xLeafPositions)
        % The units in MLCTABLE is in cm. Change it into mm to be consistent
        % with DICOM leaf positions.
        LS.xLeafPositions{i} = interp1(10*MLCTABLE(:,1), 10*MLCTABLE(:,2),LS.xLeafPositions{i}, 'linear', 'extrap');
    end
    
end

precision = precisionFluenceMap;

if (TongueGroove ==1)
    disp('Model Tongue-and-Groove effect of MLC. over-write the fluence map resolution using 0.5mm');
    precision = 0.5
end

%Get x max, min and round to precision value.
% xMax = ceil(max(vertcat(LS.xLimits{1}),[],1) / precision) * precision;
% xMin = floor(min(vertcat(LS.xLimits{1}),[],1) / precision) * precision;
% fieldSize.x = max(xMax) - min(xMin);
% fieldLim.x  = [max(xMax) min(xMin)];


xMax = ceil(max(vertcat(LS.xLimits{:}),[],1) / precision) * precision;
xMin = floor(min(vertcat(LS.xLimits{:}),[],1) / precision) * precision;
fieldSize.x = max(xMax) - min(xMin);
fieldLim.x  = [max(xMax) min(xMin)];

yMax = ceil(max(vertcat(LS.yLimits{:}),[],1) / precision) * precision;
yMin = floor(min(vertcat(LS.yLimits{:}),[],1) / precision) * precision;
fieldSize.y = max(yMax) - min(yMin);
fieldLim.y  = [max(yMax) min(yMin)];

yRes = precision;
nyElements = ceil(fieldSize.y/yRes);
xRes = precision;
nxElements = ceil(fieldSize.x/xRes);

inflMap=zeros(nyElements, nxElements);
colDividerXCoord = linspace(fieldLim.x(2), fieldLim.x(1), nxElements+1);
rowDividerYCoord = linspace(fieldLim.y(2), fieldLim.y(1), nyElements+1);

if isfield(LS, 'yLeafPositions')
    rowLeafPositions = round(interp1(rowDividerYCoord, 1:nyElements+1, LS.yLeafPositions,'linear', 'extrap'));
    rowLeafPositions = clip(rowLeafPositions, 1, nyElements+1, 'limits');
    leafBoundariesToKeep = [diff(rowLeafPositions)>0;logical(1)];
    rowLeafPositions = rowLeafPositions(leafBoundariesToKeep);
    leavesToKeep = leafBoundariesToKeep(1:end-1);
else
    %LS.xLeafPositions{1} = [xMin xMax-precision];
    LS.xLeafPositions{1} = [xMin xMax];
    LS.meterSetWeight = {1};
    rowLeafPositions = [1 nyElements+1];
    leavesToKeep = 1;
end

if length(LS.meterSetWeight) == 1
    doses = LS.meterSetWeight{:};
else
    doses = [0 diff([LS.meterSetWeight{:}])];
end

% backupMap = inflMap;
h = waitbar(0,['Generating Fluence Map From MLC Positions For Beam ',num2str(beamIndex)]);

for i=1:length(LS.xLeafPositions)
    %    inflMap = backupMap;
    nLeaves = length(LS.xLeafPositions{i})/2;
    
    if length(LS.xLimits) > 1
        jpL = LS.xLimits{i}(1);
        jpR = LS.xLimits{i}(2);
    else
        jpL = LS.xLimits{1}(1);
        jpR = LS.xLimits{1}(2);
    end
    
    lpL = LS.xLeafPositions{i}(1:nLeaves);
    lpR = LS.xLeafPositions{i}(nLeaves+1:end);
    lpLK = lpL(leavesToKeep);
    lpRK = lpR(leavesToKeep);
    lpLCols = interp1(colDividerXCoord, 1:nxElements+1, lpLK, 'linear', 'extrap');
    lpRCols = interp1(colDividerXCoord, 1:nxElements+1, lpRK, 'linear', 'extrap');
    
    %Column divider positions of jaws.
    jpLCol = interp1(colDividerXCoord, 1:nxElements+1, jpL, 'linear', 'extrap');
    jpRCol = interp1(colDividerXCoord, 1:nxElements+1, jpR, 'linear', 'extrap');
    
    lpLCols = clip(lpLCols, jpLCol, jpRCol, 'limits');
    lpRCols = clip(lpRCols, jpLCol, jpRCol, 'limits');
    
    lpLCols = round(lpLCols);
    lpRCols = round(lpRCols);
    
    
    %head scatter radiation parametrs for varian
    %! a2 = 0.078;
    %! beta = 1.79;
    %! lambda = 7.69;
    
    
    for j=1:length(lpLCols)
        % JC Aug 09 2006, change the data type of i and j into integer, because MATLAB
        % complains about it.
        j = int16(j);
        i = int16(i);
        %HCF from output ratio for MLC fields Zhu, MedPhys
        %! YMLC = rowDividerYCoord(rowLeafPositions(j)) + abs((rowDividerYCoord(rowLeafPositions(j+1)) - rowDividerYCoord(rowLeafPositions(j))))/2;
        %! YMLC = YMLC/10;
        %! sizeLeaf = abs((rowDividerYCoord(rowLeafPositions(j+1)) - rowDividerYCoord(rowLeafPositions(j))));
        %! sizeLeaf = sizeLeaf/10;
        %! HCF_UP = 1 + a2*(erf(2*lpLK(j)*beta/(10*lambda)) +  erf(2*lpRK(j)*beta/(10*lambda)))*(erf(2*(YMLC + sizeLeaf/2)/lambda) - erf(2*(YMLC - sizeLeaf/2)/lambda))/4;
        %! HCF_Down = 1 + a2*(erf(2*jpL/(10*lambda)) +  erf(2*jpR/(10*lambda)))*(erf(2*(YMLC + sizeLeaf/2)/lambda) - erf(2*(YMLC - sizeLeaf/2)/lambda))/4;
        %! HCF = HCF_UP/HCF_Down;
        %! inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, lpLCols(j):lpRCols(j)-1) = inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, lpLCols(j):lpRCols(j)-1) + HCF*doses(i);
        inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, lpLCols(j):lpRCols(j)-1) = inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, lpLCols(j):lpRCols(j)-1) + doses(i);
        %        inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, jpLCol:lpLCols(j)-1) = inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, jpLCol:lpLCols(j)-1) + leak*doses(i);
        inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, int16(jpLCol):int16(lpLCols(j)-1)) = inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, int16(jpLCol):lpLCols(j)-1) + leak*doses(i);
        %        inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, lpRCols(j):jpRCol-1) = inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, lpRCols(j):jpRCol-1) + leak*doses(i);
        inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, int16(lpRCols(j)):int16(jpRCol-1)) = inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, int16(lpRCols(j)):int16(jpRCol-1)) + leak*doses(i);
        
        if (MLC == 1)
            %!      Add leak of the MLC round leaf end of the LEFT leaf; for the grid
            %of 1mm,
            % rTCol = max(1,int16(lpLCols(j)-tongueCols));
            if (precision == 1)  %If the resolution is 1mm
                if (lpLCols(j)-4 > 0 & lpLCols(j) < nxElements)
                    % Can not assume 100% transmission underneath where the two leaf tips touch.
                    % l = repmat([0.02 0.024 0.043 0.095 0.5]-leak,length(rowLeafPositions(j):rowLeafPositions(j+1)-1),1);
                    l = repmat([0.02 0.024 0.043 0.095 0.15]-leak,length(rowLeafPositions(j):rowLeafPositions(j+1)-1),1);
                    inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, int16(lpLCols(j)-4):lpLCols(j)) = inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, int16(lpLCols(j)-4):lpLCols(j)) + l*doses(i);
                    
                end
                %!      Add leak of the MLC round leaf end of the RIGHT leaf
                if (lpRCols(j) > 0 & lpRCols(j)+4 < nxElements)   % maximum size of inflMap
                    % To include the transmission of the leaf tip: lpRCols(j),
                    % otherwise, there will be a dip where two leaf abut.
                    % l = repmat([0.5 0.095 0.043 0.024 0.02]-leak,length(rowLeafPositions(j):rowLeafPositions(j+1)-1),1);
                    l = repmat([0.15 0.095 0.043 0.024 0.02]-leak,length(rowLeafPositions(j):rowLeafPositions(j+1)-1),1);
                    inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, lpRCols(j):lpRCols(j)+4) = ...
                        inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, lpRCols(j):lpRCols(j)+4) + l*doses(i);
                end
                
            elseif (precision == 0.5)
                
                if (lpLCols(j)-9 > 0 & lpLCols(j) < nxElements)
                    l = repmat([0.02 0.023 0.024 0.035 0.043 0.066 0.095 0.13 0.15 0.25]-leak,length(rowLeafPositions(j):rowLeafPositions(j+1)-1),1);
                    inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, int16(lpLCols(j)-9):lpLCols(j)) = ...
                        inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, int16(lpLCols(j)-9):lpLCols(j)) + l*doses(i);
                    
                end
                
                if (lpRCols(j) > 0 & lpRCols(j)+9 < nxElements)
                    l = repmat([0.25 0.15 0.13 0.095 0.066 0.043 0.035 0.024 0.023 0.02]-leak,length(rowLeafPositions(j):rowLeafPositions(j+1)-1),1);
                    inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, lpRCols(j):lpRCols(j)+9) = ...
                        inflMap(rowLeafPositions(j):rowLeafPositions(j+1)-1, lpRCols(j):lpRCols(j)+9) + l*doses(i);
                end
                
            end
            
            %! Need to add the tongue-and-groove effect, i.e. the inter-leaf
            %dose leakage, dose spikes.
            %! Figure out the leaf edges.
            %! Need to know where the extra leakage starts and end, i.e. the
            %distance of groove.
            % ---------------------------------------)
            %             |-----------------------|    )
            %                                            )
            %                                              )
            %                                               )
            %                                            )
            %             |-----------------------|    )
            % ---------------------------------------)
            tongueLeak = 0.01;      % 0.01 = 5! extra leak beneath tongue and groove
            tongueToLeafTip = 5;    %mm
            if (TongueGroove == 1)
                tongueWidth = 0.5;      %mm
            else
                tongueWidth = 1;        %mm  (Tested for Bar Pattern)
            end
            % tongueTransmission = 0.15;  % 10% under dose, (Thus the underDose is (100-2*45) = 10(%).
            % Exacurate. "Make it large" of TG effect, for testing.
            tongueTransmission = 0.25;  % 10% under dose, (Thus the underDose is (100-2*45) = 10(%).
            
            % Need to figure out the "column #" where the groove starts and
            % ends.
            
            % Increase the transmission of the fluence map over the groove
            % region.
            tongueRows = int16(tongueWidth/yRes);
            tongueCols = int16(tongueToLeafTip/xRes);
            
            % Add the  leak on the  higher edges of the leaf.
            % for precision = 1mm
            % Left Leaf
            rTRow = min(rowLeafPositions(j)-1+tongueRows, nyElements);
            % The inter-leaf leakage runs throug the whole leaf length
            rTCol = max(1,int16(lpLCols(j)-tongueCols));
            
            inflMap(rowLeafPositions(j):rTRow, 1:rTCol) = ...
                inflMap(rowLeafPositions(j):rTRow, 1:rTCol) + tongueLeak*doses(i);
            
            %  One the higher portion of the leaf
            %  Temporary account only one side of the inter-leaf-leak for
            %  "precision == 1 mm'
            %  "precision == 0.5" Add the leak of the lower side.
            if precision == 0.5
                rTRow = max(1, rowLeafPositions(j+1)-1-tongueRows);
                inflMap(rowLeafPositions(j+1)-1:rTRow, 1:rTCol) = ...
                    inflMap(rowLeafPositions(j+1)-1:rTRow, 1:rTCol) + tongueLeak*doses(i);
                % To Add T-G effect
                if (j+1 <= length(lpLCols))
                    if(lpLCols(j) < lpLCols(j+1))  % Means the field is shaped by lpLCols(j+1)
                        % Need to konw the width to apply T-G effect, default is 0.5mm
                        % Need to find the length of the T-G effect region.
                        inflMap(rowLeafPositions(j+1)-1, lpLCols(j):lpLCols(j+1)-1) = ...
                            inflMap(rowLeafPositions(j+1)-1, lpLCols(j):lpLCols(j+1)-1) - tongueTransmission*doses(i);
                    elseif (lpLCols(j) > lpLCols(j+1))  %Means the field is shaped by lpLCols(j), reduce transmission for (j+1) upper edge
                        inflMap(rowLeafPositions(j+1), lpLCols(j+1):lpLCols(j)-1) = ...
                            inflMap(rowLeafPositions(j+1), lpLCols(j+1):lpLCols(j)-1) - tongueTransmission*doses(i);
                        % To be refined.
                    end
                end
                
            end
            
            % % % Right Leaf
            rTRow = min(rowLeafPositions(j)-1+tongueRows, nyElements);
            rTCol = min(lpRCols(j)-1+tongueCols, nxElements);
            
            inflMap(rowLeafPositions(j):rTRow, rTCol:nxElements) = ...
                inflMap(rowLeafPositions(j):rTRow, rTCol:nxElements) + tongueLeak*doses(i);
            
            %  One the higher portion of the leaf
            %  Temporary account only one side of the inter-leaf-leak for
            %  "precision == 1 mm'
            if precision == 0.5
                rTRow = max(1, rowLeafPositions(j+1)-1-tongueRows);
                inflMap(rowLeafPositions(j+1)-1:rTRow, rTCol:nxElements) = ...
                    inflMap(rowLeafPositions(j+1)-1:rTRow, rTCol:nxElements) + tongueLeak*doses(i);
                if (j+1 <= length(lpLCols))
                    if(lpRCols(j) < lpRCols(j+1))  % Means the field is shaped by lpLCols(j+1)
                        % Need to konw the width to apply T-G effect, default is 0.5mm
                        % Need to find the length of the T-G effect region.
                        % It equals to the length of the open area
                        %              inflMap(rowLeafPositions(j+1)-1, lpRCols(j):lpRCols(j+1)-1) = ...
                        %                  inflMap(rowLeafPositions(j+1)-1, lpRCols(j):lpRCols(j+1)-1) - tongueTransmission*doses(i);
                        inflMap(rowLeafPositions(j+1), lpRCols(j):lpRCols(j+1)-1) = ...
                            inflMap(rowLeafPositions(j+1), lpRCols(j):lpRCols(j+1)-1) - tongueTransmission*doses(i);
                    elseif (lpRCols(j) > lpRCols(j+1))  %Means the field is shaped by lpLCols(j)
                        %               inflMap(rowLeafPositions(j+1), lpRCols(j+1):lpRCols(j)-1) = ...
                        %                   inflMap(rowLeafPositions(j+1), lpRCols(j+1):lpRCols(j)-1) - tongueTransmission*doses(i);
                        inflMap(rowLeafPositions(j+1)-1, lpRCols(j+1):lpRCols(j)-1) = ...
                            inflMap(rowLeafPositions(j+1)-1, lpRCols(j+1):lpRCols(j)-1) - tongueTransmission*doses(i);
                        % The Col# is determined by the Left Col# of (j), and Right
                        % Leaf Col # of (j+1)
                        % To be refined.
                        % To be refined.
                    end
                end
            end
            
            % Also need to add the tongue and groove "underDose"
            % .....
        end
        
    end % if (MLC ==1)
    
    waitbar(i/length(LS.xLeafPositions));
    
    %        frame = inflMap;
    %        imagesc(inflMap);
    %        mi(:,:,i) = inflMap;
    %        inflMap(inflMap == 0) = 1;
    %        inflMap(inflMap ~= 0) = 2;
    %        colormap([0 0 0; 1 1 1]);
    %        %mi(:,:,i) = inflMap;
    %        %mi(i) = im2frame(inflMap, [0 0 0; 1 1 1]);
    %        drawnow;
    %        pause(.006);
end
close(h);
drawnow
colXCoord = colDividerXCoord(1:end-1) + precision/2;
rowYCoord = rowDividerYCoord(1:end-1) + precision/2;